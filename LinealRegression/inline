{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.utils import shuffle\n",
    "import seaborn as sns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta1)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    #plt.plot([4,70],[theta0+theta1*4,theta0+theta1*70],c=\"red\")\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x)\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(x,getRect(theta0,theta1,x),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(x,getRect(theta0,theta1,x),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(x,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0 =-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta1 =-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta0=-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta0=-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=-(1/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta0=-(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=-(2/self.N)*np.sum(self.X*(theta0+theta1*self.X-self.Y))\n",
    "        dTheta0=-(2/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=1000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=10000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100000,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    print(theta0)\n",
    "    print(getRect(theta0,theta1,X))\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    #print(theta0)\n",
    "    print(getRect(theta0,theta1,X))\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    #print(theta0)\n",
    "    #print(getRect(theta0,theta1,X))\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.utils import shuffle\n",
    "import seaborn as sns\n",
    "%matplotlib notebook\n",
    "\n",
    "class LinearRegression:\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    #print(theta0)\n",
    "    #print(getRect(theta0,theta1,X))\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.utils import shuffle\n",
    "import seaborn as sns\n",
    "class LinearRegression(object):\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    #print(theta0)\n",
    "    #print(getRect(theta0,theta1,X))\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.utils import shuffle\n",
    "import seaborn as sns\n",
    "class LinearRegression(object):\n",
    "    def __init__(self,learningRatio=0.1,numIterations=100,fitIntercept=True):\n",
    "        self.learningRatio=learningRatio#parametro de aprendizaje\n",
    "        self.numIterations=numIterations#numero de iteraciones\n",
    "        self.fitIntercept=fitIntercept\n",
    "        self.N=0#cantidad de datos \n",
    "        self.X=[]\n",
    "        self.Y=[]\n",
    "        self.theta0 = np.random.randn(1)[0]#se genera theta0 y theta1 aleatorios para poder ajustar bien la recta \n",
    "        self.theta1 = np.random.randn(1)[0]\n",
    "    def gradientDesent(self,theta0,theta1):\n",
    "        dTheta0=(1/self.N)*np.sum(theta0+theta1*self.X-self.Y)\n",
    "        dTheta1=(1/self.N)*np.sum((theta0+theta1*self.X-self.Y)*self.X)\n",
    "        theta0=theta0-self.learningRatio*dTheta0\n",
    "        theta1=theta1-self.learningRatio*dTheta1\n",
    "        return theta0,theta1\n",
    "    def fit(self,X,Y):    \n",
    "        self.X=X\n",
    "        self.Y=Y\n",
    "        theta0=self.theta0\n",
    "        theta1=self.theta1\n",
    "        self.N=X.shape[0]\n",
    "        for i in range(self.numIterations):\n",
    "            [theta0,theta1]=self.gradientDesent(theta0,theta1)\n",
    "        return theta0,theta1\n",
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "def getRect(theta0,theta1,x):\n",
    "    return theta1*x+theta0\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    lr=LinearRegression()\n",
    "    theta0=0\n",
    "    theta1=0\n",
    "    [theta0,theta1]=lr.fit(X,Y)\n",
    "    #print(theta0)\n",
    "    #print(getRect(theta0,theta1,X))\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {},
   "outputs": [],
   "source": [
    "class MultivariateRegression(LinearRegression)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    plt.plot(X,getRect(theta0,theta1,X),'r')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    Y=X[:,0:1]\n",
    "    X=X[:,1:2]\n",
    "    \n",
    "    return X,Y\n",
    "if __name__=='__main__':\n",
    "    [X,Y]=readData()\n",
    "    plt.scatter(X,Y)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    print(df)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    #df = df.drop(['Id'],axis=1)\n",
    "    print(df)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    print(df)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    print(df)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    print(x)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    print(X)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    plt.scatter(X,Y)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    plt.scatter(X[: ,1:2],Y)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    plt.scatter(X[: ,1:2],Y)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    plt.scatter(X[: ,1:2],Y)\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    plt.scatter(X[: ,1:2],Y)\n",
    "    plt.show\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    plt.scatter(X[: ,1:2],Y)\n",
    "    plt.show()\n",
    "readData()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [],
   "source": [
    "def readData():\n",
    "    df = pd.read_csv('Iris.csv')\n",
    "    df = df.drop(['Id'],axis=1)\n",
    "    rows = list(range(100,150))\n",
    "    df = df.drop(df.index[rows])  \n",
    "    Y = []\n",
    "    target = df['Species']\n",
    "    for val in target:\n",
    "        if(val == 'Iris-setosa'):\n",
    "            Y.append(0)\n",
    "        else:\n",
    "            Y.append(1)\n",
    "    df = df.drop(['Species'],axis=1)\n",
    "    X = df.values.tolist()\n",
    "    X, Y = shuffle(X,Y)\n",
    "    X=np.array(X)\n",
    "    plt.scatter(X,Y)\n",
    "    plt.show()\n",
    "readData()"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
